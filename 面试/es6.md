# es6
## const let

#### 不存在变量提升

>  let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错

```js
console.log(foo); // 输出undefined
console.log(bar); // 报错ReferenceError

var foo = 2;
let bar = 2;
```

### 暂时性死区
> 在变量初始化前访问该变量会导致 ReferenceError。该变量处在一个自块顶部到初始化处理的“暂存死区”中。

```js
function do_something() {
  console.log(bar); // undefined
  console.log(foo); // ReferenceError
  var bar = 1;
  let foo = 2;
}
```

### 不允许重复声明

### const 申明值不变、
> 对于申明一个复合类型变量，const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变


## 解构赋值
### 默认值
> NOTE! 如果一个数组成员不严格等于undefined，默认值是不会生效

### 

### 数值和布尔值的解构赋值
> 解构赋值时，如果等号右边是数值和布尔值，则会先转为对象
```js
let {toString: s} = true;
s === Boolean.prototype.toString // true
```

## Symbol

> 一个symbol值能作为对象属性的标识符；这是该数据类型仅有的目的
> Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法

#### 使用场景（充分利用Symbol唯一性）
- 使用Symbol来作为对象属性名(key)
- 使用Symbol定义类的私有属性/方法
- 使用Symbol来替代常量

## Set



## Map

> Map 对象保存**键值对**，并且能够记住键的原始**插入顺序**。**任何值**(对象或者原始值) 都可以作为一个键或一个值

### 产生背景
> 传统上键值对只能用字符串当作键的限制

### 复合类型做为键
> Map的键是跟内存地址绑定的，只要内存地址不一样，就视为两个键

```js
// bad
var map = new Map();

map.set(['a'], 555);
map.get(['a']) // undefined

// good
const b = {name: 'nice'}
map.set(c, 5555)
map.get(c)  // 5555
```

### 在频繁增删键值对的场景下表现更好

## WeakMap
> WeakMap 对象是一组键/值对的集合，其中的键是**弱引用**的。其**键**必须是**对象**，而值可以是任意的
> 如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap(防止内存泄漏)


## Proxy
> Proxy 对象用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等(元编程)

## Array

#### 类数组
> 可以通过索引访问元素，并且拥有 length 属性；没有数组的其他方法

## 函数

- 函数的参数设置默认值
- 
### 函数的length属性
> 函数的length属性，将返回没有指定默认值的参数个数

### rest参数
> 注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错

### 扩展运算符
> 将一个数组，变为参数序列
> 替代数组的apply方法

### name属性
> 返回该函数的函数名 ES6的匿名函数的name属性会返回实际的函数名

### 箭头函数
- 箭头函数不会创建自己的this,它只会从自己的作用域链的上一层继承this
- 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。
- 不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。
- 不可以使用yield命令，因此箭头函数不能用作Generator函数。

### 尾调用优化
> 当一个函数所做的最后一件事是调用了另一个函数，而后者不需要返回调用者函数中再去做任何动作时
> 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧,只保留内层函数的调用帧,这将大大节省内存
- 应用 尾递归优化 或者 采用“循环”换掉“递归”

- [参考](https://juejin.im/post/5a4d898a518825698e7277d1)

## 对象


## 模块化

#### ES6 是在预编译阶段去加载模块的，而 CommonJS 是在运行阶段去加载模块的

- import 命令会被 JavaScript 引擎静态分析，优先于模块内的其他内容执行。

- export 命令会有变量声明提前的效果。
  
#### ES6 模块输出的是值的引用，CommonJS 模块输出的是值的拷贝。

- [参考](https://juejin.im/entry/5a879e28f265da4e82635152)







### 如何处理肥波序列函数
1 处理缓存 
2 使用WeakMap处理缓存
3 使用尾调优优化


### 
### 模板字符串
1 String.raw() 是一个字符串模板的标签函数，是用来获取一个模板字符串的原始字符串
2 带标签的模板字符串
 > 用函数解析模板字符串， 标签函数的第一个参数包含了字符串值得数组， 其余参数对应插入值表达式

### 数组方法
1 push
> 把一个或多个元素添加到数组的尾部，并返回数组的新长度，会更改原数组。
2 flat
> 遍历指定深度的数组，并讲所有元素合并为新数组

### Object
1 Object.seal
> 封闭一个对象 不能删除添加一个熟悉  但是可以编辑 以及一个数据属性不能被重新定义成为访问器属性
2 Object.freeze
> 冻结对象所有属性不可变


### delete操作（不能一次性掌握）
1 从对象上删除指定属性,重点要考虑下面情况
- 删除对象上面没有的属性
- 删除一个对象自己的属性和删除一个对象原型上的属性区别
- 删除var let const等申明的属性
- 删除设置为不可配置的属性
- 删除数组元素

### es6 模块
- 导出模块可以动态修改  但是到处模块不行
- import关键词会被提到最前面执行
- 命名导出  默认导出  重定向导出

### Intl.NumberFormat(比较新)
> 对语言敏感的格式化数字类的构造器类

### class
- 可以类声明或者类表达式定义一个类，但不会提升